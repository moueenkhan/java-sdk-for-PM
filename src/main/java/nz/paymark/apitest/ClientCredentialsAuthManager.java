/*
 * PayMarkEFTPOSLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package nz.paymark.apitest;

import java.io.IOException;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import nz.paymark.apitest.controllers.OAuthAuthorizationController;
import nz.paymark.apitest.exceptions.ApiException;
import nz.paymark.apitest.http.client.HttpClient;
import nz.paymark.apitest.http.request.HttpRequest;
import nz.paymark.apitest.models.OAuthToken;

/**
 * Utility class for OAuth 2 authorization and token management.
 */
public class ClientCredentialsAuthManager implements AuthManager, ClientCredentialsAuth {

    /**
     * Private instance of OAuth 2 API controller.
     */
    private OAuthAuthorizationController oAuthApi;

    private String oAuthClientId;

    private String oAuthClientSecret;

    private OAuthToken oAuthToken;

    /**
     * Constructor.
     */
    public ClientCredentialsAuthManager(String oAuthClientId, String oAuthClientSecret,
            OAuthToken oAuthToken, Configuration config, HttpClient httpClient) {
        this.oAuthApi = new OAuthAuthorizationController(config, httpClient,
                new HashMap<String, AuthManager>());
        this.oAuthClientId = oAuthClientId;
        this.oAuthClientSecret = oAuthClientSecret;
        this.oAuthToken = oAuthToken;
    }

    /**
     * String value for oAuthClientId.
     * @return oAuthClientId
     */
    public String getOAuthClientId() {
        return oAuthClientId;
    }

    /**
     * String value for oAuthClientSecret.
     * @return oAuthClientSecret
     */
    public String getOAuthClientSecret() {
        return oAuthClientSecret;
    }

    /**
     * OAuthToken value for oAuthToken.
     * @return oAuthToken
     */
    public OAuthToken getOAuthToken() {
        return oAuthToken;
    }

    /**
     * Checks if provided credentials matched with existing ones.
     * @param oAuthClientId String value for credentials.
     * @param oAuthClientSecret String value for credentials.
     * @param oAuthToken OAuthToken value for credentials.
     * @return true if credentials matched.
     */
    public boolean equals(String oAuthClientId, String oAuthClientSecret, OAuthToken oAuthToken) {
        return oAuthClientId.equals(getOAuthClientId())
                && oAuthClientSecret.equals(getOAuthClientSecret())
                && ((getOAuthToken() == null && oAuthToken == null)
                        || (getOAuthToken() != null && oAuthToken != null
                                && oAuthToken.toString().equals(getOAuthToken().toString())));
    }

    /**
     * Converts this ClientCredentialsAuthManager into string format.
     * @return String representation of this class
     */
    @Override
    public String toString() {
        return "ClientCredentialsAuthManager [" + "oAuthClientId=" + oAuthClientId
                + ", oAuthClientSecret=" + oAuthClientSecret + ", oAuthToken=" + oAuthToken + "]";
    }

    /**
     * Fetch the OAuth token asynchronously.
     * @param additionalParameters Additional parameters to send during authorization.
     */
    public CompletableFuture<OAuthToken> fetchTokenAsync(
            final Map<String, Object> additionalParameters) {
        final Map<String, Object> aparams =
                additionalParameters == null ? new HashMap<String, Object>()
                : additionalParameters;

        return oAuthApi.createRequestTokenAsync(
            getBasicAuthForClient(),
            null,
            aparams).thenApply(token -> {
                return token;
            });
    }

    /**
     * Fetch the OAuth token asynchronously.
     */
    public CompletableFuture<OAuthToken> fetchTokenAsync() {
        return fetchTokenAsync(null);
    }

    /**
     * Fetch the OAuth token.
     * @param additionalParameters Additional parameters to send during authorization.
     */
    public OAuthToken fetchToken(Map<String, Object> additionalParameters)
            throws ApiException, IOException {
        final Map<String, Object> aparams =
                additionalParameters == null ? new HashMap<String, Object>()
                : additionalParameters;

        OAuthToken token = oAuthApi.createRequestToken(
            getBasicAuthForClient(),
            null,
            aparams);

        if (token.getExpiresIn() != null && token.getExpiresIn() != 0) {
            token.setExpiry((System.currentTimeMillis() / 1000L) + token.getExpiresIn());
        }

        return token;
    }

    /**
     * Fetch the OAuth token.
     */
    public OAuthToken fetchToken() throws ApiException, IOException {
        return fetchToken(null);
    }

    /**
     * Build authorization header value for basic auth.
     * @return Authorization header value for this client.
     */
    private String getBasicAuthForClient() {
        String val = oAuthClientId + ":" + oAuthClientSecret;
        return "Basic " + new String(Base64.getEncoder().encodeToString(val.getBytes()));
    }


    /**
     * Check if client is authorized.
     * @throws ApiException when token is null or expired.
     */
    private void checkAuthorization() throws ApiException {
        if (getOAuthToken() == null) {
            throw new ApiException(
                    "Client is not authorized. An OAuth token is needed to make API calls.");
        }

        if (isTokenExpired()) {
            throw new ApiException(
                    "OAuth token is expired. A valid token is needed to make API calls.");
        }
    }

    /**
     * Has the OAuth token expired?.
     * @return True if expired
     */
    public boolean isTokenExpired() {
        if (getOAuthToken() == null) { 
            throw new IllegalStateException("OAuth token is missing.");
        }

        return getOAuthToken().getExpiry() != null 
            && getOAuthToken().getExpiry() < (System.currentTimeMillis() / 1000L); 
    }

    /**
     * Create authorization header for API calls.
     * @return Authorization header
     */
    private String getAuthorizationHeader() {
        return "Bearer " + getOAuthToken().getAccessToken();
    }

    /**
     * Adds authentication to the given HttpRequest.
     */
    public HttpRequest apply(HttpRequest httpRequest) throws ApiException, IOException {
        checkAuthorization();
        httpRequest.getHeaders().add("Authorization", getAuthorizationHeader());
        return httpRequest;
    }

    /**
     * Asynchronously adds authentication to the given HttpRequest.
     */
    public CompletableFuture<HttpRequest> applyAsync(HttpRequest httpRequest) {
        try {
            checkAuthorization();
        } catch (ApiException e) {
            CompletableFuture<HttpRequest> failedFuture = new CompletableFuture<>();
            failedFuture.completeExceptionally(e);
            return failedFuture;
        }
        httpRequest.getHeaders().add("Authorization", getAuthorizationHeader());
        return CompletableFuture.completedFuture(httpRequest);
    }

}
